heap sort follow binary tree and heap property (min max)
insertion and deletion same as heap property

if there are n nodes then there are n/2 leaf nodes

Inplace Heap Sort
Send Feedback
Given an integer array of size n. Sort this array (in decreasing order) using heap sort.
Space complexity should be O(1).
Input Format :
Line 1 : Integer n, Array size
Line 2 : Array elements, separated by space
Output Format :
Array elements after sorting
Constraints :
1 <= n <= 10^6
Sample Input:
6 
2 6 8 5 4 3
Sample Output:
8 6 5 4 3 2


10 5 8 1 4 6 7
          10 
      5         8
    1   4     6    7
    
    7 nodes 7//2 -1 =2 
    loop n to 0
    
    
#Time complexity of heapify is O(Logn). Time complexity of createAndBuildHeap() is O(n) and overall time complexity of Heap Sort is O(nLogn).
    
## Read input as specified in the question.
## Print output as specified in the question.
def down_heapify(arr,i,n):
    
    parentIndex = i
    leftChildIndex = 2*parentIndex+1
    rightChildIndex = 2*parentIndex+2
    
    while leftChildIndex<n:
        minIndex = parentIndex
        if arr[minIndex]<arr[leftChildIndex]:
            minIndex = leftChildIndex
        if rightChildIndex < n and arr[minIndex]<arr[rightChildIndex]:
            minIndex = rightChildIndex
        if minIndex == parentIndex:
            break
        
        arr[minIndex],arr[parentIndex] = arr[parentIndex],arr[minIndex]
        parentIndex = minIndex
        leftChildIndex = 2*parentIndex+1
        rightChildIndex = 2*parentIndex+2
    
    return
        
    
def heapSort(arr):
    ##build the heap for non leaf nodes for every index
    n = len(arr)
    for  i in range(n//2-1,-1,-1):
        down_heapify(arr,i,n)
    ###Removing n elements from heap and put then in correct position  ie sorting 
    ######process
    swap brings smallest elemnt to last ie to last index n-1
    again heapify upto  n-2
    sawap brings smallest element to 2nd last position
    for i in range(n-1,0,-1):
        arr[0],arr[i] = arr[i],arr[0]
        down_heapify(arr,0,i)
	
    return

n = int(input())
arr = [int(i) for i in input().split()]
heapSort(arr)
#for decreasing order
for i in arr[::-1]:      ### only arr:  for increasing order
    print(i,end=" ")

    
    
    
import heapq    ####inbulit function to create heap
Min heap
li= [1,5,4,8,7,9,11]
heapq.heapify(li)
print(li)
---- 1,5,4,8,7,9,11
heapq.heappush(li,2)
----1,2,5,4,7,9,11,8

heapq.heappop(li)  
### 1   remove min element

print(li)
###2,5,4,8,7,9,11

heapq.heapreplace(li,6)  ### replace min element with 6 and heapify

print(li)   4,5,6,8,7,9,11


Max heap

heapq._heapify_max(li)
heapq._heappop_max(li)
heapq._heapreplace_max(li,6)
################go to 0 index , position of new element in array
heapq._siftdown_max(li,0,len(l1)-1)



