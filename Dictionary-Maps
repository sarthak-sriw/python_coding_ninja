






########### Print all words with frequency k
def kfreqwords(s,k):
  words=s.split()
  d={}
  for word in words:
    d[word]=d.get(word,0) + 1
    
  for word in d:
    if d[word]==k:
      print(word)
      
      
######## Maximum Frequency

def maxFreq(l):
    d={}
    for i in l:
        d[i] = d.get(i,0) +1
    max=l[0]
    for i in l:
        if d[max] < d[i]:
            max=i
    return max

      
      
#### Pair Sum To 0
      
def pairSum0(l):
    l.sort()
    d={}
    for i in l:
        d[i] = d.get(i,0) +1
        
    for  i in l:
        if i==0:
            for j in range(d[i]):
                print(i,i)
            d[i]=0        
        elif -i in l:
            freq = d[i]*d[-i]
            for j in range(freq):
                print(i,-i)
            
            d[i],d[-i]=0,0
            
In computer science, a Hash table or a Hashmap is a type of data structure that maps keys to its value pairs (implement abstract array data types). It basically makes use of a function that computes an index value that in turn holds the elements to be searched, inserted, removed, etc. This makes it easy and fast to access data. In general, hash tables store key-value pairs and the key is generated using a hash function.
            
################### How to insert in Map
each index has a Linked List

class MapNode:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None
        
class Map:
  
    def __init__(self):
        self.bucketSize = 10
        self.buckets = [None for i in range(self.bucketSize)]
        self.count = 0
        
    def size(self):
        return self.count
        
    def getBucketIndex(self, hc):
      return abs(hc)%self.bucketSize
      
    def insert(self, key, value):   # First task is to find the index
                                    # At the index, if same key is present then change the corresponding value of it
    # If same key is not present then create a new Node, make newNode.next = head, self.buckets[index] = newNode and 
    # increment the count of that bucket
    
    hc = hash(key)
    index = getBucketIndex(hc)
    head = self.buckets[index]
    
    while head is not None:
        if head.key == key:
            head.value = value
            return
        head = head.next
    
    newNode = MapNode(key,value)
    self.buckets[index] = newNode
    newNode.next = head
    self.count += 1
    
    
    
    
    
m = Map()
m.insert('Sar', 2)
print(m.size())
m.insert('Sam', 7)
print(m.size())
m.insert('Sar', 4)  # It hasn't inserted the new node of key 'Fazeel' instead it just changed the value for of that key
print(m.size())


O/P
1
2
2
    
    
############ Insert and delete in hash map

class MapNode:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None
        
class Map:
    def __init__(self):
        self.bucketSize = 10
        self.buckets = [None for i in range(self.bucketSize)]
        self.count = 0
        
    def size(self):
        return self.count
    
    def getBucketIndex(self,hc):
        return (abs(hc)%(self.bucketSize))
    
    def insert(self, key, value):
        hc = hash(key)
        index = self.getBucketIndex(hc)
        head = self.buckets[index]
        while head is not None:
            if head.key == key:
                head.value = value
                return 
            head = head.next
        
        # After iterating the LL make head pointing at buckets
        head = self.buckets[index] 
        newNode = MapNode(key, value)
        newNode.next = head
        self.buckets[index] = newNode
        self.count += 1
    
    def search(self.key):
    
        hc = hash(key)
        index = self.getBucketIndex(hc)
        head = self.buckets[index]
        while head is not None:
            if head.key == key:
                return head.value
                return 
            head = head.next
            
        return None
        
    def delete(self.key):
  
        hc = hash(key)
        index = self.getBucketIndex(hc)
        head = self.buckets[index]
        prev = None
        while head is not None:
            curr = head
            if head.key == key:
                if prev == None:
                    self.buckets[index] = head.next
                    return
                else:
                    prev.next = head.next
                
                self.count -= 1
                return head.value            
            prev = head
            head = head.next
            
        return None
            
            
        
m = Map()
m.insert('Sar', 2)
print(m.size())

print(m.getValue('Sar'), "Got Value of Fazeel")
m.insert('Sam', 7)
print(m.size())
m.insert('Sar', 4)  # It hasn't inserted the new node of key 'Fazeel' instead it just changed the value for of that key
print(m.size())
print(m.getValue('Sar'), "Got Value of Fazeel")
print(m.getValue('Sam'), "Got Value of Usmani")
print(m.getValue('Sarrrr'))

print(m.remove('Sar'))
print(m.getValue('Sam'), "Got Value of Usmani")
    
        
        

1
2 Got Value of Sar
2
2
4 Got Value of Sar
7 Got Value of Sam
None
4
7 Got Value of Sam
      
    

    
class MapNode:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None
        
class Map:
    def __init__(self):
        self.bucketSize = 10
        self.buckets = [None for i in range(self.bucketSize)]
        self.count = 0
        
    def size(self):
        return self.count
    
    def getBucketIndex(self,hc):
        return (abs(hc)%(self.bucketSize))
    
    def rehash(self):
        temp = self.buckets
        self.buckets = [None for i in range(2*self.bucketSize)]
        self.bucketSize = 2*self.bucketSize
        self.count = 0     # However we're increasing at the time of insertion
        
        for head in temp:
            while head is not None:
                self.insert(head.key, head.value)
                head = head.next
    
    def loadFactor(self):
        return self.count/self.bucketSize
    
    def insert(self, key, value):
        hc = hash(key)
        index = self.getBucketIndex(hc)
        head = self.buckets[index]
        while head is not None:
            if head.key == key:
                head.value = value
                return 
            head = head.next
        
        # After iterating the LL make head pointing at buckets
        head = self.buckets[index] 
        newNode = MapNode(key, value)
        newNode.next = head
        self.buckets[index] = newNode
        self.count += 1
        loadFactor = self.count/self.bucketSize    
        if loadFactor >= 0.7:
            self.rehash()
        
        
    def getValue(self, key):
        hc = hash(key)
        index = self.getBucketIndex(hc)
        head = self.buckets[index]
        while head is not None:
            if head.key == key:
                return head.value
            head = head.next
            
        return None
            
            
    def remove(self, key):
        hc = hash(key)
        index = self.getBucketIndex(hc)
        head = self.buckets[index]
        prev = None
        while head is not None:
            if head.key == key:
                
                if prev == None:
                    self.buckets[index] = head.next
                else:
                    prev.next = head.next
                    
                self.count -=1
                return head.value
            
            prev = head    
            head = head.next
            
        return None
        
        
        
        
        m = Map()

for i in range(10):
    m.insert('abc' + str(i), i + 1)
    print(m.loadFactor())

for i in range(10):
    print("abc" + str(i) + ":" , m.getValue('abc'+str(i)))
